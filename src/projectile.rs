use std::marker::PhantomData;

use notan::egui::epaint::ahash::HashSet;

use crate::{
    core::*,
    entity_insights::EntityInsights,
    equipment::{EntityUnequippedEvt, Equipment},
    interaction::{
        Interactable, Interaction, InteractionStartedEvt, InteractionSystem,
        TryUninteractTargetedReq,
    },
    needs::NeedMutator,
    physics::{Hitbox, HitboxType, Shape},
    storage::Storage,
    timed::{TimedEmit, TimedRemove},
};

use rand::Rng;

/// Defines a projectile to be generated by [`ProjectileGenerator`]s.
#[derive(Clone, Debug)]
pub struct ProjectileDefn {
    pub lifetime: f32,
    pub speed: f32,
    pub spread: f32,
    pub on_hit: NeedMutator,
}

/// Entities tagged with this components will be able to generate projectiles upon interaction.
#[derive(Clone, Debug)]
pub struct ProjectileGenerator {
    pub proj: ProjectileDefn,
    pub cooldown: Option<f32>,
}

/// [`ProjectileGenerator`]s denote an interaction, which lets them shoot a projectile.
impl Interaction for ProjectileGenerator {
    fn priority() -> usize {
        Storage::priority() + 10
    }

    fn can_start(actor: &EntityRef, target: &EntityRef, state: &State) -> bool {
        // A [`ProjectileGenerator`] can be interacted with iff they are being equipped.
        state
            .select_one::<(Equipment,)>(actor)
            .map(|(actor_equipment,)| actor_equipment.contains(target))
            .unwrap_or(false)
    }
}

/// A request to generate a projectile from the wrapped entity.
#[derive(Clone, Copy, Debug)]
pub struct GenerateProjectileReq(EntityRef);

/// A system that handles projectile generation by [`ProjectileGenerator`]s.
#[derive(Clone, Copy, Debug)]
pub struct ProjectileGenerationSystem;

impl System for ProjectileGenerationSystem {
    fn update(&mut self, _: &UpdateContext, state: &State, cmds: &mut StateCommands) {
        // Try to automatically uninteract from the activated [`ProjectileGenerator`]s upon unequipping them.
        state.read_events::<EntityUnequippedEvt>().for_each(|evt| {
            if InteractionSystem::<Storage>::interaction_exists(
                &evt.equipment_entity,
                &evt.entity,
                state,
            ) {
                cmds.emit_event(TryUninteractTargetedReq::<ProjectileGenerator>::new(
                    evt.equipment_entity,
                    evt.entity,
                ));
            }
        });
        // In response to projectile generator activation events, emit generate projectile request.
        state
            .read_events::<InteractionStartedEvt<ProjectileGenerator>>()
            .for_each(|evt| {
                cmds.emit_event(GenerateProjectileReq(evt.target));
            });
        // Handle the generate projectile requests.
        state
            .read_events::<GenerateProjectileReq>()
            .filter_map(|evt| {
                state
                    .select_one::<(
                        Interactable<ProjectileGenerator>,
                        ProjectileGenerator,
                        Transform,
                    )>(&evt.0)
                    .map(|c| (evt.0, c))
            })
            .for_each(|(p_gen_entity, (interactable, p_gen, trans))| {
                // Make sure that the generator is active.
                if interactable.actors.len() == 0 {
                    return;
                }
                // Compute the new velocity of the projectile.
                let rand_spread = if p_gen.proj.spread > 0. {
                    rand::thread_rng().gen_range(0.0..p_gen.proj.spread) - p_gen.proj.spread / 2.
                } else {
                    0.
                };
                let angles = trans.deg + rand_spread;
                let mut dir = notan::math::Vec2::from_angle(angles.to_radians());
                dir.y = -dir.y; // y axis is inverted!
                let new_pos = notan::math::vec2(trans.x, trans.y) + dir * 20.;
                let mut new_trans = *trans;
                new_trans.x = new_pos.x;
                new_trans.y = new_pos.y;
                let vel = dir * p_gen.proj.speed;
                let vel = Velocity { x: vel.x, y: vel.y };
                let anchor_parent = EntityInsights::of(&p_gen_entity, state).anchor_parent;
                // Determine the friendly entities of the projectile, which are...
                // ... the generator itself
                let mut friendly_entities = vec![p_gen_entity];
                // ... and the anchor parent of the generator
                friendly_entities.extend(anchor_parent);
                // Create the projectile entity.
                cmds.create_from((
                    new_trans,
                    vel,
                    Lifetime {
                        remaining_time: p_gen.proj.lifetime,
                    },
                    Hitbox(HitboxType::Ghost, Shape::Circle(5.)),
                    // Do not hit the anchor parent.
                    Hitter::new(friendly_entities),
                    SuicideOnHit,
                    ApplyOnHit::new(Some(0.), p_gen.proj.on_hit.clone()),
                ));
                // If cooldown was set, remove the activatable component until the cooldown ends.
                if let Some(cooldown_time) = p_gen.cooldown {
                    cmds.set_component(
                        &p_gen_entity,
                        TimedEmit::new(cooldown_time, GenerateProjectileReq(p_gen_entity)),
                    );
                }
            });
    }
}

/// Represents an entity that can impact other entities on collision.
#[derive(Clone, Debug)]
pub struct Hitter {
    /// Hitting these entities will do nothing.
    friendly_entities: HashSet<EntityRef>,
}

impl Hitter {
    pub fn new(exceptions: impl IntoIterator<Item = EntityRef>) -> Self {
        Self {
            friendly_entities: HashSet::from_iter(exceptions),
        }
    }
}

/// An event denoting a [`Hitter`] hitting a concrete entity.
#[derive(Clone, Copy, Debug)]
pub struct HitEvt {
    pub hitter: EntityRef,
    pub target: EntityRef,
}

/// A system that listens to [`Hitter`] collision and emits appropriate [`HitEvt`]s.
#[derive(Clone, Copy, Debug)]
pub struct HitSystem;

impl System for HitSystem {
    fn update(&mut self, _: &UpdateContext, state: &State, cmds: &mut StateCommands) {
        // Emit the projectile hit events.
        state.select::<(Hitter,)>().for_each(|(e, (hitter,))| {
            let hitter_insights = EntityInsights::of(&e, state);
            hitter_insights
                .new_collision_starters
                .into_iter()
                // Make sure that we do not consider friendly entities.
                .filter(|coll_target| !hitter.friendly_entities.contains(coll_target))
                // Make sure that the target's hitbox is concrete.
                .filter(|coll_target| {
                    state
                        .select_one::<(Hitbox,)>(coll_target)
                        .map(|(hb,)| hb.0.is_concrete())
                        .unwrap_or(false)
                })
                .for_each(|coll_target| {
                    cmds.emit_event(HitEvt {
                        hitter: e,
                        target: coll_target,
                    })
                });
        });
    }
}

/// Entities tagged with this component will be removed after they hit another component.
#[derive(Clone, Copy, Debug)]
pub struct SuicideOnHit;

/// A system that removes the [`SuicideOnHit`] entities from the system when they hit a concrete entity.
#[derive(Clone, Copy, Debug)]
pub struct SuicideOnHitSystem;

impl System for SuicideOnHitSystem {
    fn update(&mut self, _: &UpdateContext, state: &State, cmds: &mut StateCommands) {
        // Remove the entities that should be removed after a hit.
        state.read_events::<HitEvt>().for_each(|evt| {
            if let Some(_) = state.select_one::<(SuicideOnHit,)>(&evt.hitter) {
                cmds.mark_for_removal(&evt.hitter);
            }
        });
    }
}

/// The entities that are hit by this entity will be applied this component with an optional time.
#[derive(Clone, Copy, Debug)]
pub struct ApplyOnHit<T: Component> {
    time: Option<f32>,
    component: T,
}

impl<T: Component> ApplyOnHit<T> {
    pub fn new(time: Option<f32>, component_to_apply: T) -> Self {
        Self {
            time,
            component: component_to_apply,
        }
    }
}

/// A system that handles the entities that apply `T` to the entities they hit.
#[derive(Clone, Debug)]
pub struct ApplyOnHitSystem<T: Component>(PhantomData<T>);

impl<T: Component> Default for ApplyOnHitSystem<T> {
    fn default() -> Self {
        Self(Default::default())
    }
}

impl<T: Component> System for ApplyOnHitSystem<T> {
    fn update(&mut self, _: &UpdateContext, state: &State, cmds: &mut StateCommands) {
        state.read_events::<HitEvt>().for_each(|evt| {
            if let Some((apply_on_hit,)) = state.select_one::<(ApplyOnHit<T>,)>(&evt.hitter) {
                let target = evt.target;
                let component_to_apply = apply_on_hit.component.clone();
                // Add the component.
                cmds.set_component(&target, component_to_apply);
                // Optionally, request the removal of the said component after a certain time.
                if let Some(time) = apply_on_hit.time {
                    cmds.set_component(&target, TimedRemove::<T>::new(time));
                }
            }
        });
    }
}
